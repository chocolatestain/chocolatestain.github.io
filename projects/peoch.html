<!DOCTYPE HTML>
<html>
	<head>
		<title>Peoch - chocolatestain.github.io</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="../assets/css/main.css" />
	</head>
	<body class="is-preload">

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Main -->
					<div id="main">
						<div class="inner">

							<!-- Header -->
								<header id="header">
									<a href="../index.html" class="logo"><strong>CHOCOLATESTAIN's Portfolio</strong></a>
								</header>

							<!-- Content -->
								 
									<header class="main">
										<h1>Peoch</h1>
									</header>
									<div style = "text-align: center; padding-bottom: 30px;"><video src="../videos/Peoch 시연영상.mp4" controls></video></div>
									<div class="carousel-container">
									    <div class="carousel-images">
									        <img src="../images/pic01.jpg" alt="Project Image 1" class="active" />
									        <img src="../images/pic02.jpg" alt="Project Image 2" />
									        <img src="../images/pic03.jpg" alt="Project Image 3" />
									    </div>
									    <button class="prev-button">&lt;</button>
									    <button class="next-button">&gt;</button>
									</div>
<p>
	<h2>🏆 신한 금융 SW 아카데미 4기 8회차 우수상 수상 🏆</h2>
    <h2>프로젝트 개요</h2>
    고객의 미래 가능성에 투자하는 AI 기반 금융 플랫폼
	<br>
	<br>
	<h2>사람의 가능성에 투자하다<br>
	Peo + ch = People + 같이/가치</h2>
</p>
<p>
    <h2>기술 스택</h2>
    <ul>
        <li><b>프론트앤드:</b> React, JavaScript</li>
        <li><b>백엔드:</b> Spring Boot, Java</li>
        <li><b>데이터베이스:</b> MySQL</li>
        <li><b>배포:</b> Jenkins, Linux 자체 서버</li>
        <li><b>버전 관리:</b> Git, GitHub</li>
    </ul>
</p>
<p>
	<h2>개발 기간</h2>
	2025.01 ~ 2025.03
</p>
<p>
    <h2>주요 기능</h2>
    <ul>
        <li>사용자 커스텀 카드(혜택, 디자인) 제작</li>
        <li>사용자 정보를 통한 AI 사용자 소득 예측</li>
        <li>도출해낸 예상 소득에 기반한 고객 미래 투자</li>
        <li>사용자 성장 지원</li>
    </ul>
</p>
<p>
    <h2>담당 파트</h2>
</p>
<p>Jenkins를 활용한 CI/CD 자동화 및 인프라 운영, 관리자 및 사용자 대시보드, 메인 페이지 디자인, 기타 UI/UX 설계를 담당하였습니다.</p>
<p>
 <h2>겪었던 어려움 및 해결 과정</h2>
    <hr>

    <h3>풀스택 개발 방식에서 오는 일관성 유지 문제</h3>
    <p>
        프로젝트를 진행하며 가장 큰 어려움 중 하나는 <b>풀스택 개발 방식에서 오는 일관성 유지 문제</b>였습니다. 프론트엔드와 백엔드를 기능별로 나누어 개발하다 보니, 다음과 같은 부분에서 개발 표준을 지키는 데 많은 노력이 필요했습니다.
    </p>
    <ul>
        <li><b>백엔드</b>: 코딩 컨벤션, 디렉토리 구조, API 호출 방식 등을 통일하는 데 어려움을 겪었습니다. 각 기능마다 독립적으로 개발되면서 자칫 중복되거나 일관성 없는 코드가 생성될 위험이 있었습니다.</li>
        <li><b>프론트엔드</b>: 사용 라이브러리, 클래스 이름 지정 규칙, 디자인 가이드라인 등을 통일하여 UI/UX의 일관성을 유지하는 것이 중요했지만, 개별 기능 개발 시 이러한 규칙을 철저히 지키는 데 어려움이 있었습니다.</li>
    </ul>
    <p>
        이러한 문제를 해결하기 위해 <b>사전에 명확한 개발 표준을 수립하고, 주기적인 코드 리뷰를 통해 이를 준수하도록 노력했습니다.</b> 특히, 백엔드에서는 Spring Boot를 활용하여 공통 모듈과 규칙을 정의하고, 프론트엔드에서는 React와 styled-components를 사용하여 재사용 가능한 컴포넌트와 디자인 시스템을 구축하여 일관성을 확보하고자 했습니다.
    </p>

    <h3>기능별 개발 과정에서 파트 간 정보 전달의 어려움</h3>
    <p>
        다음으로, <b>기능별 개발 과정에서 파트 간 정보 전달의 어려움</b>이 있었습니다. 백엔드를 기능 단위로 분리하여 개발하다 보니, 각 기능에 필요한 데이터 모델 설계 및 정보 흐름을 정의하는 데 있어 협업의 중요성을 절감했습니다.
    </p>
    <ul>
        <li><b>DTO(Data Transfer Object) 설계</b>: 각 기능에서 필요한 데이터 구조를 정의하고 이를 프론트엔드와 공유하는 과정에서 DTO 설계의 일관성과 효율성을 확보하는 것이 중요했습니다.</li>
        <li><b>ERD(Entity-Relationship Diagram) 설계</b>: 데이터베이스 테이블 간의 관계를 명확히 정의하고, 기능별 요구사항을 반영하는 데 있어 초기 ERD 설계의 중요성과 변경 관리의 어려움을 경험했습니다.</li>
        <li><b>정보 흐름 설계</b>: 사용자 요청부터 데이터 처리, 응답까지 이어지는 전반적인 정보의 흐름을 기능별로 명확하게 정의하고 공유하는 데 어려움이 있었습니다.</li>
    </ul>
    <p>
        이러한 문제점을 극복하기 위해 <b>초기 설계 단계에서 팀원들과 밀접하게 소통하며 ERD와 API 명세서를 상세하게 작성했습니다.</b> 또한, 주기적인 스크럼 회의를 통해 각 파트의 진행 상황을 공유하고, DTO 및 정보 흐름에 대한 변경 사항을 즉시 반영하여 혼선을 줄였습니다. Jenkins를 활용한 지속적인 통합 및 배포 환경을 구축하여 변경 사항을 빠르게 공유하고 검증할 수 있도록 지원했습니다.
    </p>

    <h2>인프라 및 배포 단계에서의 도전과 해결</h2>
    <hr>

    <h3>인프라 리소스 관리 및 효율화 경험</h3>
    <p>
        프로젝트 초기, 가상 머신(Rocky Linux 기반)에 할당된 리소스는 <b>4GB 메모리와 1 CPU</b>였습니다. 당시에는 단순히 서비스 구동만을 염두에 두었지 <b>CI/CD 구현에 필요한 리소스는 고려하지 못했습니다.</b> 저는 특정 브랜치 푸시 시 자동 빌드가 이루어지는 시나리오를 구상하여 Jenkins를 설정했으나, <b>프론트엔드 빌드(npm build) 작업이 예상보다 훨씬 많은 리소스를 요구하는 작업</b>임을 간과했습니다.
    </p>
    <p>
        결국, 초기 할당된 리소스 내에서 빌드 작업이 시작되자 <b>리소스 과다 사용으로 인해 인스턴스가 중단되는 상황</b>이 발생했습니다. 당시 저에게는 VM의 root 권한이 없어 담당자에게 연락하여 인스턴스를 재구동하는 번거로운 과정을 거쳐야 했습니다. 이 과정에서 현재 진행 중인 CI/CD 구축 내용을 설명드렸고, 담당자분께서는 저희 팀 인스턴스의 리소스를 <b>8GB 메모리와 4 CPU로 추가 할당</b>해주셨습니다.
    </p>
    <p>
        하지만 저는 반복적으로 담당자를 귀찮게 하고 싶지 않았고, 할당된 리소스를 효율적으로 사용하며 Jenkins를 안정적으로 운영할 방법을 모색했습니다.
    </p>
    <ul>
        <li><b>Jenkins 컨테이너 리소스 제한</b>: Jenkins 컨테이너 구동 시, Docker(또는 컨테이너 런타임) 명령에 <code>--memory=4g --cpus=2</code> 옵션을 추가하여 <b>Jenkins 컨테이너가 사용할 수 있는 최대 메모리를 4GB, CPU를 2개로 명시적으로 제한</b>했습니다. 이는 전체 VM 리소스(8GB/4CPU)를 고려하여 Jenkins가 필요한 자원만 사용하도록 최적화하고, VM 전체의 리소스 고갈을 방지하는 동시에 다른 서비스와의 리소스 경합을 줄이는 조치였습니다.</li>
        <li><b><code>npm build</code> 명령어 최적화</b>: Jenkinsfile 내에서 <code>npm build</code> 명령을 실행할 때 <code>CI=false npm run build || true</code>와 같이 작성했습니다.
            <ul>
                <li><code>CI=false</code>: 이 환경 변수는 React 등의 프론트엔드 빌드 시 CI 환경에서 빌드가 실패할 수 있는 특정 경고(warnings)들을 오류로 처리하지 않도록 하여, 불필요한 빌드 실패를 줄였습니다.</li>
                <li><code>|| true</code>: 이 부분은 <code>npm run build</code> 명령이 실패하더라도 Jenkins Job 자체는 성공으로 처리되도록 하여, 빌드 과정에서 발생할 수 있는 사소한 문제가 전체 CI/CD 파이프라인을 중단시키지 않도록 유연성을 확보했습니다.</li>
            </ul>
        </li>
    </ul>
    <p>
        이러한 노력들을 통해 한정된 리소스 내에서 CI/CD 파이프라인을 안정적으로 운영하는 방법을 체득할 수 있었습니다. 예상치 못한 문제 발생 시 적극적으로 해결 방안을 모색하고, 시스템의 안정성을 확보하기 위해 노력하는 경험은 인프라 운영 역량을 강화하는 데 큰 도움이 되었습니다.
    </p>

    <h3>CI/CD 구축 과정에서의 고민과 개선</h3>
    <p>
        CI/CD(지속적 통합/지속적 배포) 환경은 Jenkins를 활용하여 구축했습니다. 초기에는 Nginx, Spring Boot, 데이터베이스 컨테이너를 하나의 Pod으로 묶고, Jenkins 컨테이너는 배포의 역할만을 수행한다는 판단 하에 별도의 Pod으로 분리하여 관리하려 했습니다.
    </p>
    <p>
        그러나 이 과정에서 <b>Jenkins의 웹 UI에서 다른 서비스의 API를 호출할 때 CORS(Cross-Origin Resource Sharing) 문제가 발생</b>했습니다. Jenkins를 별도의 Pod으로 운영하며 프론트엔드 빌드 결과물(예: 리액트 앱)이 Jenkins API나 다른 백엔드 API와 통신하려 할 때, 브라우저 보안 정책에 의해 요청이 차단되는 상황이 발생한 것입니다.
    </p>
    <p>
        당시 촉박한 일정 속에서 이 문제를 빠르게 해결하기 위해 <b>Jenkins에 적절한 플러그인을 설치하고 설정을 통해 CORS 제약을 우회하는 방법을 택했습니다.</b> (예: 'CORS Filter Plugin' 또는 유사한 기능을 제공하는 플러그인을 활용) 이로써 Jenkins를 독립적인 Pod으로 유지하면서도 필요한 API 통신이 가능하도록 조치할 수 있었습니다.
    </p>

    <h2>느낀 점 및 향후 개선 방향</h2>
    <hr>

    <p>
        이번 프로젝트를 통해 기술적인 역량뿐만 아니라 <b>협업의 중요성, 체계적인 계획의 필요성, 그리고 초기 설계의 중요성</b>을 깊이 깨달았습니다. 결과물만 놓고 보면 다음과 같은 아쉬움이 남습니다.
    </p>
    <ol>
        <li><b>개발 표준의 부재와 기술 부채 발생</b>:
            <ul>
                <li>API 명세 및 네이밍 규칙이 통일되지 않아 개발자 간 혼선이 발생했습니다. 특히 <b>코딩 컨벤션이 제대로 지켜지지 않은 부분</b>은 코드의 가독성을 떨어뜨리고 유지보수를 어렵게 했습니다.</li>
                <li>가장 큰 문제점 중 하나는 <b>API 호출 방식이 개발자마다 각기 달랐던 점</b>입니다. 어떤 팀원은 <code>fetch</code>를, 어떤 팀원은 <code>axios</code>를 사용했으며, <code>axios</code>를 사용하는 경우에도 API 주소를 하드코딩하거나 인스턴스를 활용하는 등 제각각이었습니다. 이로 인해 추후 배포 작업 시 <b>CORS(Cross-Origin Resource Sharing) 문제가 발생했을 때 모든 API 호출 로직을 처음부터 갈아엎고 재작업해야 하는 불필요한 공수가 발생</b>했습니다. 이는 초기 단계에서 명확한 개발 표준을 수립하지 않았을 때 발생하는 기술 부채의 심각성을 깨닫게 해주었습니다.</li>
            </ul>
        </li>
        <li><b>디자인 시스템의 미흡과 UI/UX의 일관성 부족</b>:
            <ul>
                <li>디자인 파트에서 <b>디자인을 전담으로 담당해본 인원이 없어</b>, 최대한 미리 정해줘야 할 부분을 고민했지만 역부족이었습니다. Figma를 활용하여 기본적인 <b>오브젝트 및 페이지 디자인</b>, 컬러 팔레트, 폰트, Breadcrumb과 같은 공통 요소를 어느 정도 정의했지만, <b><code>h1</code> 폰트 크기, 좌우 패딩 수치 등과 같은 세부적인 디자인 가이드라인을 구체적으로 확립하지 못했습니다.</b></li>
                <li>더 나아가, <b>CSS 클래스의 속성 설정 및 상황(상태)별 클래스 배정(예: 버튼 hover, active 상태 등)에 대한 명확한 규칙을 수립하지 못했습니다.</b> 이는 통일된 디자인 가이드의 부재와 맞물려 큰 문제로 이어졌습니다.</li>
                <li>또한, <b>프론트엔드 디자인 시 사용해야 할 라이브러리도 통일하지 못했습니다.</b> 팀원별 개발 능력이 모두 달라 각자 익숙한 방식이 달랐기 때문입니다. 본인은 React에서 <code>styled-components</code>를 사용했지만, 다른 팀원은 순수 CSS를 사용하거나 또 다른 디자인 라이브러리를 사용하는 등 파편화되어 있었습니다. 이처럼 <b>각기 다른 라이브러리와 스타일링 방식은 통일된 CSS 클래스 관리와 상황별 스타일 적용을 더욱 어렵게 만들었습니다.</b> 이 모든 문제는 초기 개발 단계에서 합의 후 넘어가야 하는 부분이었으나, 시간 부족 등의 이유로 미리 정하지 못했습니다.</li>
                <li>결과적으로 전체적인 틀은 유사했지만, 각 기능별 UI를 살펴보면 구조적 또는 항목별로 <b>따로 노는 듯한 느낌을 주어 UI/UX의 일관성이 부족</b>했습니다. 이는 파트별 역할 분담이 아닌 기능별 구현 방식의 단점 중 하나로, 디자인 시스템의 중요성을 절감하는 계기가 되었습니다.</li>
            </ul>
        </li>
        <li><b>백엔드 설계 및 데이터 흐름 관리의 어려움</b>:
            <ul>
                <li>백엔드 ERD(Entity-Relationship Diagram) 설계 시, 단순히 DB 스키마 간의 관계 설정뿐만 아니라 <b>데이터의 흐름(Data Flow)까지 완벽하게 고려하지 못한 점</b>이 아쉬웠습니다.</li>
                <li>풀스택 개발 방식과 맞물리면서, 다른 개발자가 작업한 부분의 데이터나 API를 사용할 때마다 API 명세서를 확인해야 했고, 그것으로 부족하면 해당 개발자에게 직접 물어봐야 하는 상황이 빈번하게 발생했습니다. 이는 <b>DTO(Data Transfer Object) 설계의 불완전함으로 이어져, 기존 DTO에 특정 항목의 <code>attribute</code>가 없어 새로 DTO를 작성하고 API를 새로 파야 하는 불필요한 재작업이 발생</b>했습니다.</li>
                <li>이 경험을 통해 <b>초기 ERD 설계의 중요성</b>을 뼈저리게 느꼈습니다. 모든 API 및 컴포넌트 간의 데이터 흐름을 면밀히 고려하고, API 및 DTO를 <b>최소한으로 사용하여 재사용성과 일관성을 극대화하도록 설계</b>해야 한다는 점을 깨달았습니다.</li>
            </ul>
        </li>
    </ol>

    <h2>결론 및 배운 점</h2>
    <hr>

    <p>
        이번 프로젝트는 여러 한계점과 아쉬움에도 불구하고, <b>정해진 기간 내에 기능하는 결과물을 완성했다는 점에서 스스로에게 큰 의미</b>가 있는 경험이었습니다. 절대적으로 보면 개선할 부분이 많지만, 그만큼 <b>배운 점 또한 셀 수 없이 많았던 프로젝트</b>입니다.
    </p>
    <p>
        풀스택 방식으로 프로젝트를 진행하면서, <b>각 파트(프론트엔드, 백엔드, 디자인) 간의 협업에 대한 실질적인 '체크리스트'가 머릿속에 정립</b>되었습니다.
    </p>
    <ul>
        <li><b>프론트엔드 관점</b>:
            <ul>
                <li>초기 협업 시 어떤 디자인 가이드라인, 라이브러리, API 호출 규칙 등을 명확히 정해야 하는지 체감했습니다.</li>
                <li>백엔드를 직접 개발해보니, 프론트엔드에서 코드를 어떻게 작성하면 백엔드에서 데이터를 활용하고 API를 처리하기에 효율적인지, 혹은 프론트엔드에서 넘어가는 정보가 백엔드에서 어떻게 활용되는지를 명확히 이해하게 되었습니다. 이를 통해 더 효율적인 데이터 전송 및 활용 방안을 모색할 수 있었습니다.</li>
            </ul>
        </li>
        <li><b>백엔드 관점</b>:
            <ul>
                <li>사용자의 다양한 환경과 보안을 고려하여 최대한의 연산과 핵심 비즈니스 로직을 백엔드에서 처리해야 한다는 중요성을 다시 한번 깨달았습니다.</li>
                <li>프론트엔드에서 어느 정도까지의 기능 구현이 가능한지, 그리고 프론트엔드에서 어떤 형태로 데이터를 받아야 백엔드에서 처리하기 용이한지를 직접 경험하면서, 백엔드 기능을 더욱 견고하고 효율적으로 설계하는 데 큰 도움을 받았습니다.</li>
            </ul>
        </li>
        <li><b>디자인 파트 관점</b>:
            <ul>
                <li>디자인 시스템 구축 시 어떤 항목들을 미리 세밀하게 설계해야 하는지, 그리고 기술적인 제약으로 인해 어떤 디자인 요소는 구현이 어렵거나 많은 공수가 필요한지를 파악할 수 있게 되었습니다.</li>
            </ul>
        </li>
    </ul>
    <p>
        결론적으로, 이번 프로젝트는 아쉬운 점들이 분명 있었지만, 그 과정에서 얻은 <b>전체적인 개발 프로세스와 파트 간 상호작용에 대한 깊이 있는 이해는 그 어떤 경험보다 값진 자산</b>이 되었습니다. 이러한 배움을 바탕으로 앞으로는 더 체계적이고 효율적인 프로젝트를 성공적으로 이끌어 나갈 준비가 되어 있습니다.
    </p>
									
									<ul class="actions">
										<li><a href="https://github.com/chocolatestain/7hillguys-back" class="button primary">GitHub</a></li>
									</ul>

								</section>

						</div>
					</div>

				<!-- Sidebar -->
					<div id="sidebar">
						<div class="inner">

							<!-- Menu -->
								<nav id="menu">
									<header class="major">
										<h2>Menu</h2>
									</header>
									<ul>
										<li><a href="../index.html">Homepage</a></li>
										<li><a href="../index.html#about-me">About Me</a></li>
										<li><a href="../index.html#projects">Projects</a></li>
										<li><a href="../index.html#contact">Contact</a></li>
									</ul>
								</nav>
							<!-- Section -->
								<section id="contact">
									<header class="major">
										<h2>Get in touch</h2>
									</header>
									<ul class="contact">
										<li class="icon brands fa-github"><a href="https://github.com/chocolatestain">github.com/chocolatestain</a></li>
									</ul>
								</section>
						</div>
					</div>

			</div>

		<!-- Scripts -->
			<script src="../assets/js/jquery.min.js"></script>
			<script src="../assets/js/browser.min.js"></script>
			<script src="../assets/js/breakpoints.min.js"></script>
			<script src="../assets/js/util.js"></script>
			<script src="../assets/js/main.js"></script>

	</body>
</html>